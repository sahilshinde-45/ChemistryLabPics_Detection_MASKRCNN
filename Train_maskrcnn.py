# -*- coding: utf-8 -*-
"""ML-MASKRCNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1yU93rRgIXKI7Ay-1YhnfZoFOAE1VxcB9
"""



# from google.colab import drive
# drive.mount('/content/drive')

train_path = '/content/drive/MyDrive/ML-PROJECT_2024/Train'
test_path  = '/content/drive/MyDrive/ML-PROJECT_2024/Test'

#!pip install opencv-python
#!pip install mrcnn-tf115
#!pip install keras
#!pip install tensorboard

import random
from torchvision.models.detection.faster_rcnn import FastRCNNPredictor
import numpy as np
import torch.utils.data
import cv2
import torchvision.models.segmentation
import torch
import os
import matplotlib.pyplot as plt
from torch.utils.tensorboard import SummaryWriter
import keras
import skimage.io

writer = SummaryWriter()

batchSize=2
imageSize=[600,600]

test_imgs=[]
for pth in os.listdir(test_path):
  test_imgs.append(test_path+"/"+pth+"//")

imgs=[]
for pth in os.listdir(train_path):
    imgs.append(train_path+"/"+pth +"//")

imgs[:5]

imgs[1]

img = plt.imread(f'{imgs[1]}'+'Image.jpg')

plt.imshow(img)

def loadData():
  batch_Imgs=[]
  batch_Data=[]

  for i in range(batchSize):

        """
         Loading images and creating the data objects
        """
        idx = random.randint(0,len(imgs)-1)
        img = cv2.imread(os.path.join(imgs[idx], "Image.jpg"))
        img = cv2.resize(img, imageSize, cv2.INTER_LINEAR)

        maskDir = os.path.join(imgs[idx], "Vessels")

        if not os.path.exists(maskDir):
            continue

        masks=[]

        for mskName in os.listdir(maskDir):
            vesMask = cv2.imread(maskDir+'/'+mskName, 0)
            vesMask = (vesMask > 0).astype(np.uint8)
            vesMask=cv2.resize(vesMask,imageSize,cv2.INTER_NEAREST)

            if np.count_nonzero(vesMask) > 0:
                masks.append(vesMask)

        num_objs = len(masks)

        if num_objs==0: return loadData()

        boxes = torch.zeros([num_objs,4], dtype=torch.float32)

        for i in range(num_objs):
            x,y,w,h = cv2.boundingRect(masks[i])
            boxes[i] = torch.tensor([x, y, x+w, y+h])

        masks = torch.as_tensor(masks, dtype=torch.uint8)
        img = torch.as_tensor(img, dtype=torch.float32)

        data = {}
        data["boxes"] =  boxes
        data["labels"] =  torch.ones((num_objs,), dtype=torch.int64)
        data["masks"] = masks
        batch_Imgs.append(img)
        batch_Data.append(data)


  batch_Imgs = torch.stack([torch.as_tensor(d) for d in batch_Imgs],0)
  batch_Imgs = batch_Imgs.swapaxes(1, 3).swapaxes(2, 3) # This is done to maintain the format.

  return batch_Imgs, batch_Data

model=torchvision.models.detection.maskrcnn_resnet50_fpn(pretrained=True)

in_features = model.roi_heads.box_predictor.cls_score.in_features
model.roi_heads.box_predictor=FastRCNNPredictor(in_features,num_classes=2)

optimizer = torch.optim.AdamW(params=model.parameters(), lr=1e-5)

model.train()

import numpy as np

# Initialize variables for early stopping
best_loss = float('inf')
patience = 5
patience_count = 0

for i in range(1000):
    images, targets = loadData()
    images = list(image for image in images)
    targets = [{k: v for k, v in t.items()} for t in targets]

    optimizer.zero_grad()
    loss_dict = model(images, targets)
    losses = sum(loss for loss in loss_dict.values())

    losses.backward()
    optimizer.step()

    print(f'Epoch {i}, Training Loss: {losses.item()}')
    writer.add_scalar('Training Loss', losses.item(), i)

    if i % 100 == 0:
        torch.save(model.state_dict(), f"Final.torch")
        print(f"Saved model at epoch {i}")

    # Early stopping based on training loss
    if losses.item() < best_loss:
        best_loss = losses.item()
        patience_count = 0
    else:
        patience_count += 1
        if patience_count >= patience:
            print(f'Early stopping at epoch {i} due to lack of improvement.')
            break

writer.close()

# Commented out IPython magic to ensure Python compatibility.
# %load_ext tensorboard

# Commented out IPython magic to ensure Python compatibility.
# %tensorboard --logdir=runs/ --host localhost --port 6006

#!lsof -i:6006

#!kill 25149

